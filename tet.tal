( devices )

|00 @System     [ &vector $2 &wst      $1 &rst    $1 &pad   $4 &r      $2 &g      $2 &b    $2 &debug  $1 &halt $1 ]
|10 @Console    [ &vector $2 &read     $1 &pad    $5 &write $1 &error  $1 ]
|20 @Screen     [ &vector $2 &width    $2 &height $2 &auto  $1 &pad    $1 &x      $2 &y    $2 &addr   $2 &pixel $1 &sprite $1 ]
|30 @Audio0     [ &vector $2 &position $2 &output $1 &pad   $3 &adsr   $2 &length $2 &addr $2 &volume $1 &pitch $1 ]
|80 @Controller [ &vector $2 &button   $1 &key    $1 ]
|c0 @DateTime   [ &year   $2 &month    $1 &day    $1 &hour  $1 &minute $1 &second $1 &dotw $1 &doty   $2 &isdst $1 ]

( variables )

|0000

( program )

@well
	$c8 ( 10x20 blocks, 1 byte per block )
	&end
@piece
	&type $1
	&rot $1
	&x $1 &y $1 ( offset from well top-left )

|0100 ( -> )

	( theme ) 
	#0fa5 .System/r DEO2 
	#0df2 .System/g DEO2 
	#0ad9 .System/b DEO2

	( vectors )
	;on-frame .Screen/vector DEO2
	;on-button .Controller/vector DEO2

	( resize )
	#0100 .Screen/width DEO2
	#0100 .Screen/height DEO2
BRK

@on-frame ( -> )

	.well &loop
		#00 OVR STZ
		INC DUP .well/end LTH ,&loop JCN POP

	;put-piece
	;pieces
		#00 .piece/type LDZ #30 SFT ADD2
		#00 .piece/rot LDZ #10 SFT ADD2
		LDA2
	.well
		.piece/y LDZ #0a MUL
		.piece/x LDZ
		ADD ADD
	each-piece-block
	POP2

	draw-well
BRK

@on-button ( -> )
	.Controller/button DEI 

	DUP #10 AND ,&up JCN ,&p-up JMP &up
		.piece/y LDZ #01 SUB .piece/y STZ
		&p-up
	DUP #20 AND ,&dn JCN ,&p-dn JMP &dn
		.piece/y LDZ INC .piece/y STZ
		&p-dn
	DUP #40 AND ,&lt JCN ,&p-lt JMP &lt
		.piece/x LDZ #01 SUB .piece/x STZ
		&p-lt
	DUP #80 AND ,&rt JCN ,&p-rt JMP &rt
		.piece/x LDZ INC .piece/x STZ
		&p-rt 
	DUP #01 AND ,&a JCN ,&p-a JMP &a
		.piece/type LDZ INC #05 DIVk MUL SUB .piece/type STZ
		&p-a
	DUP #02 AND ,&b JCN ,&p-b JMP &b
		.piece/rot LDZ INC #04 DIVk MUL SUB .piece/rot STZ
		&p-b
	POP BRK

BRK

@draw-well ( -- )
	#0000 .Screen/x DEO2
	#0000 .Screen/y DEO2
	#83 .Screen/pixel DEO

	#0058 .Screen/x DEO2
	#0038 .Screen/y DEO2
	#01 .Screen/auto DEO
	.well &loop
		( load well byte )
		LDZk draw-block
	INC DUP .well/end LTH ,&loop JCN POP
JMP2r

@draw-block ( well-value -- )
	DUP ,&block JCN

	( draw blank space )
		;blank-chr .Screen/addr DEO2
		.Screen/sprite DEO
		,&inc JMP

	&block ( draw block )
		;block-icn .Screen/addr DEO2
		#80 ORA .Screen/sprite DEO

	&inc ( adjust screen x/y )
		.Screen/x DEI2 #00a8 LTH2 ,&no-eol JCN
			#0058 .Screen/x DEO2
			.Screen/y DEI2 #0008 ADD2 .Screen/y DEO2
		&no-eol
JMP2r

@put-piece ( well-idx -- )
	#01 SWP STZ
JMP2r

@each-piece-block ( addr16 piece16 well-idx -- addr16 )
	#21 ADD ( go backward from bottom-right )
	#01 ( col-count, 0-3 )
	SWP2 ( well-idx col-count piece16 )

	&loop

	( test whether a piece block is at well-idx )
	DUP #01 AND ,&ok JCN ,&p-ok JMP
	&ok 
		( put well-idx on top and call addr16 ) 
		SWP2 ROT2 OVR2 SWP OVR2 JSR2
		( return stack to previous state )
		POP SWP2 ROT2
	&p-ok

	SWP2 ( piece16 well-idx col-count )
	( col-count %= 4 )
	#04 DIVk MUL SUB
	( if col-count == 0, move to next row )
	SWP OVR ,&inc JCN #06 SUB
	&inc 
	( decrement well-idx )
	#01 SUB SWP
	( increment col-count )
	INC
	SWP2 ( well-idx col-count piece16 )

	( have we run out of piece blocks to try? )
	#01 SFT2 DUP2 #0000 GTH2
		,&loop JCN

	POP2 POP2 ( well-idx col-count piece16 -- )

	( leave addr16 on the stack )
JMP2r

( assets )

@pieces
	&i 0f00 4444 0f00 4444
	&s 4620 6c00 4620 6c00
	&l 4460 0e80 c440 2e00
	&t 0e40 4c40 4e00 4640
	&b cc00 cc00 cc00 cc00
@blank-chr
	ffff ffff ffff ffff
@block-icn
	7e81 8181 8181 817f
	007f 7f7f 7f7f 7f7f
