( devices )

|00 @System     [ &vector $2 &wst      $1 &rst    $1 &pad   $4 &r      $2 &g      $2 &b    $2 &debug  $1 &halt $1 ]
|10 @Console    [ &vector $2 &read     $1 &pad    $5 &write $1 &error  $1 ]
|20 @Screen     [ &vector $2 &width    $2 &height $2 &auto  $1 &pad    $1 &x      $2 &y    $2 &addr   $2 &pixel $1 &sprite $1 ]
|30 @Audio0     [ &vector $2 &position $2 &output $1 &pad   $3 &adsr   $2 &length $2 &addr $2 &volume $1 &pitch $1 ]
|80 @Controller [ &vector $2 &button   $1 &key    $1 ]
|c0 @DateTime   [ &year   $2 &month    $1 &day    $1 &hour  $1 &minute $1 &second $1 &dotw $1 &doty   $2 &isdst $1 ]

( variables )

|0000

@cur  &type $1 &rot $1 &x $1 &y $1 &vec $2
@next &type $1 &rot $1 &x $1 &y $1 &vec $2 &blocked $1

@debounce $1
@timer    &tick $1 &speed $1

( program )

|0100 ( -> )

	( theme ) 
	#0fa5 .System/r DEO2 
	#0df2 .System/g DEO2
	#0ad9 .System/b DEO2

	( vectors )
	;on-frame .Screen/vector DEO2
	;on-button .Controller/vector DEO2

	( resize )
	#0100 .Screen/width DEO2
	#0100 .Screen/height DEO2

	#20 .timer/speed STZ
	#07 .cur/x STZ
	#03 .cur/y STZ

	init-well
	set-cur-piece
BRK

@on-frame ( -> )

	.cur/type LDZ .next/type STZ
	.cur/rot LDZ .next/rot STZ
	.cur/y LDZ .next/y STZ
	.cur/x LDZ .next/x STZ

	( inputs )
	.Controller/button DEI
	#02 pressed ,&p-b JCN
		.next/rot LDZ INC #04 DIVk MUL SUB .next/rot STZ
		&p-b
	#40 pressed ,&p-lt JCN
		.next/x LDZ #01 SUB .next/x STZ
		&p-lt
	#80 pressed ,&p-rt JCN
		.next/x LDZ INC .next/x STZ
		&p-rt 
	POP

	( test x change )
	.next/rot LDZ .cur/rot LDZ EQU 
	.next/x LDZ .cur/x LDZ EQU 
	AND ,&x-done JCN
	test-next-piece ,&x-blocked JCN
	unset-cur-piece
	.next/rot LDZ .cur/rot STZ
	.next/x LDZ .cur/x STZ
	set-cur-piece
	,&x-done JMP
	&x-blocked
	.cur/rot LDZ .next/rot STZ
	.cur/x LDZ .next/x STZ
	&x-done

	#00 ( inc-y? )
	( gravity )
	.timer/tick LDZ INC .timer/speed LDZ DIVk MUL SUB .timer/tick STZk POP ,&no-gravity JCN
		INC
		&no-gravity
	( down button )
	.Controller/button DEI #20 AND ,&dn JCN ,&p-dn JMP
		&dn INC
		&p-dn
	( test y change )
	#01 LTH ,&y-done JCN
	.cur/y LDZ INC .next/y STZ
	test-next-piece ,&y-blocked JCN
	unset-cur-piece
	.next/y LDZ .cur/y STZ
	set-cur-piece
	,&y-done JMP
	&y-blocked
	freeze-cur-piece
	new-cur
	&y-done

	draw-well
BRK

@on-button ( -> )
	.Controller/button DEI .debounce LDZ AND .debounce STZ
BRK

@pressed ( button code -- nope )
	DUP2 AND ,&held JCN ,&no JMP 
	&held
		DUP .debounce LDZ AND ,&no JCN
		DUP .debounce LDZ ORA .debounce STZ
		POP #00 JMP2r
	&no
		POP #01 JMP2r

@new-cur ( -- )
	#07 .cur/x STZ
	#00 .cur/y STZ
	#00 .cur/rot STZ
	.cur/type LDZ INC #05 DIVk MUL SUB .cur/type STZ
JMP2r

@set-test-pattern ( -- )
	;well &loop
		DUP2 DUP #03 AND ROT ROT STA
	INC2 DUP2 ;well/end LTH2 ,&loop JCN POP2
JMP2r

@init-well ( -- )
	;well &loop
		DUP2 #0ff0 AND2
		DUP2 #0170 GTH2 ,&skip JCN
		POP2 DUP2 #000f AND2
		DUP #04 LTH ,&skip JCN
		DUP #0d GTH ,&skip JCN
		POP2 DUP2 #00 ,&set JMP
		&skip POP2 DUP2 #02 
		&set ROT ROT STA
	INC2 DUP2 ;well/end LTH2 ,&loop JCN POP2
JMP2r

@draw-well ( -- )
	#0000 .Screen/x DEO2
	#0000 .Screen/y DEO2
	#83 .Screen/pixel DEO

	#0058 .Screen/x DEO2
	#0038 .Screen/y DEO2
	#01 .Screen/auto DEO

	;well &loop
		DUP2 #0ff0 AND2
		DUP2 #0040 LTH2 ,&skip JCN
		DUP2 #0170 GTH2 ,&skip JCN
		POP2 DUP2 #000f AND2
		DUP #04 LTH ,&skip JCN
		DUP #0d GTH ,&skip JCN
		POP2
		LDAk draw-block
		DUP2
		&skip
		POP2
	INC2 DUP2 ;well/end LTH2 ,&loop JCN POP2
JMP2r

@draw-block ( well-value -- )
	DUP ,&block JCN

	( draw blank space )
		;blank-chr .Screen/addr DEO2
		.Screen/sprite DEO
		,&inc JMP

	&block ( draw block )
		;block-icn .Screen/addr DEO2
		#80 ORA .Screen/sprite DEO

	&inc ( adjust screen x/y )
		.Screen/x DEI2 #00a8 LTH2 ,&no-eol JCN
			#0058 .Screen/x DEO2
			.Screen/y DEI2 #0008 ADD2 .Screen/y DEO2
		&no-eol
JMP2r

@test-next-piece ( -- blocked )
	#00 .next/blocked STZ
	;test-piece-func .next/vec STZ2
	.next each-piece-block
	.next/blocked LDZ
JMP2r

@test-piece-func ( well-idx piece -- )
	piece-well-addr
	LDA #02 AND .next/blocked LDZ ORA .next/blocked STZ
JMP2r

@set-cur-piece ( -- )
	;set-piece-func .cur/vec STZ2
	.cur each-piece-block
JMP2r

@set-piece-func ( well-idx piece -- )
	piece-well-addr 
	#01 ROT ROT STA
JMP2r

@unset-cur-piece ( -- )
	;unset-piece-func .cur/vec STZ2
	.cur each-piece-block
JMP2r

@unset-piece-func ( well-idx piece -- )
	piece-well-addr LDAk #fe AND ROT ROT STA
JMP2r

@freeze-cur-piece ( -- )
	;freeze-piece-func .cur/vec STZ2
	.cur each-piece-block
JMP2r

@freeze-piece-func ( well-idx piece -- )
	piece-well-addr #02 ROT ROT STA
JMP2r

@piece-well-addr ( well-idx piece -- well-addr )
	INC INC INCk LDZ SWP LDZ SWP
	#00 SWP #0010 MUL2
	ROT #00 SWP ADD2
	;well ADD2
	ROT #00 SWP ADD2
JMP2r

@each-piece-block ( piece -- )
	DUP
	LDZk #30 SFT ( type ) 
	SWP INC LDZ #10 SFT ( rot )
	ADD #00 SWP 
	;pieces ADD2 LDA2 ( piece16 )
	#33 ( go backward from bottom-right )
	#01 ( col-count, 0-3 )
	SWP2 ( piece well-idx col-count piece16 )

	&loop

	( test whether a piece block is at well-idx )
	DUP #01 AND ,&ok JCN ,&p-ok JMP
	&ok 
		( stash piece16 and arrange to call piece/vec )
		STH2 SWP ROT ( col-count well-idx piece )
		( call piece/vec with ( well-idx piece ) )
		DUP2 DUP #04 ADD LDZ2 JSR2
		( restore stack )
		SWP ROT STH2r ( piece well-idx col-count piece 16 )
	&p-ok

	SWP2 ( piece piece16 well-idx col-count )
	( col-count %= 4 )
	#04 DIVk MUL SUB
	( if col-count == 0, move to next row )
	SWP OVR ,&inc JCN #0c SUB
	&inc 
	( decrement well-idx )
	#01 SUB SWP
	( increment col-count )
	INC
	SWP2 ( piece well-idx col-count piece16 )

	( shift piece16 right, and stop if no more blocks )
	#01 SFT2 DUP2 #0000 GTH2
		,&loop JCN

	POP2 POP2 POP
JMP2r

( assets )

@pieces
	&i 0f00 4444 0f00 4444
	&s 4620 6c00 4620 6c00
	&l 4460 0e80 c440 2e00
	&t 0e40 4c40 4e00 4640
	&b 6600 6600 6600 6600
@blank-chr
	ffff ffff ffff ffff
@block-icn
	7e81 8181 8181 817f
	007f 7f7f 7f7f 7f7f

( game data )

|4000

@well $200 &end
