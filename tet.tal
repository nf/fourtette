( devices )

|00 @System     [ &vector $2 &wst      $1 &rst    $1 &pad   $4 &r      $2 &g      $2 &b    $2 &debug  $1 &halt $1 ]
|10 @Console    [ &vector $2 &read     $1 &pad    $5 &write $1 &error  $1 ]
|20 @Screen     [ &vector $2 &width    $2 &height $2 &auto  $1 &pad    $1 &x      $2 &y    $2 &addr   $2 &pixel $1 &sprite $1 ]
|30 @Audio0     [ &vector $2 &position $2 &output $1 &pad   $3 &adsr   $2 &length $2 &addr $2 &volume $1 &pitch $1 ]
|80 @Controller [ &vector $2 &button   $1 &key    $1 ]
|c0 @DateTime   [ &year   $2 &month    $1 &day    $1 &hour  $1 &minute $1 &second $1 &dotw $1 &doty   $2 &isdst $1 ]

( variables )

|0000

( program )

@cur  &type $1 &rot $1 &x $1 &y $1
@next &type $1 &rot $1 &x $1 &y $1 &ok $1

|0100 ( -> )

	( theme ) 
	#0fa5 .System/r DEO2 
	#0df2 .System/g DEO2 
	#0ad9 .System/b DEO2

	( vectors )
	( ;on-frame .Screen/vector DEO2 )
	( ;on-button .Controller/vector DEO2 )

	( resize )
	#0100 .Screen/width DEO2
	#0100 .Screen/height DEO2

	init-well

	#06 .cur/x STZ
	#06 .cur/y STZ

	set-cur-piece

	( set-test-pattern )
	draw-well
BRK

@set-test-pattern ( -- )
	;well &loop
		DUP2 DUP #03 AND ROT ROT STA
	INC2 DUP2 ;well/end LTH2 ,&loop JCN POP2
JMP2r

@init-well ( -- )
	;well &loop
		DUP2 #0ff0 AND2
		DUP2 #0040 LTH2 ,&skip JCN
		DUP2 #0170 GTH2 ,&skip JCN
		POP2 DUP2 #000f AND2
		DUP #04 LTH ,&skip JCN
		DUP #0d GTH ,&skip JCN
		POP2 DUP2 #00 ,&set JMP
		&skip POP2 DUP2 #02 
		&set ROT ROT STA
	INC2 DUP2 ;well/end LTH2 ,&loop JCN POP2
JMP2r

@draw-well ( -- )
	#0000 .Screen/x DEO2
	#0000 .Screen/y DEO2
	#83 .Screen/pixel DEO

	#0058 .Screen/x DEO2
	#0038 .Screen/y DEO2
	#01 .Screen/auto DEO

	;well &loop
		DUP2 #0ff0 AND2
		DUP2 #0040 LTH2 ,&skip JCN
		DUP2 #0170 GTH2 ,&skip JCN
		POP2 DUP2 #000f AND2
		DUP #04 LTH ,&skip JCN
		DUP #0d GTH ,&skip JCN
		POP2
		LDAk draw-block
		DUP2
		&skip
		POP2
	INC2 DUP2 ;well/end LTH2 ,&loop JCN POP2
JMP2r

@draw-block ( well-value -- )
	DUP ,&block JCN

	( draw blank space )
		;blank-chr .Screen/addr DEO2
		.Screen/sprite DEO
		,&inc JMP

	&block ( draw block )
		;block-icn .Screen/addr DEO2
		#80 ORA .Screen/sprite DEO

	&inc ( adjust screen x/y )
		.Screen/x DEI2 #00a8 LTH2 ,&no-eol JCN
			#0058 .Screen/x DEO2
			.Screen/y DEI2 #0008 ADD2 .Screen/y DEO2
		&no-eol
JMP2r

@test-next-piece ( -- ok )
	;test-next-piece-block .next each-piece-block
JMP2r

@test-next-piece-block ( well-idx -- )
	.next pos-to-well-addr LDA #02 AND
	.next/ok LDZ ORA
JMP2r

@set-cur-piece ( -- )
	;set-cur-piece-block .cur each-piece-block
JMP2r

@set-cur-piece-block ( well-idx -- )
	#01 SWP .cur pos-to-well-addr STA
JMP2r

@pos-to-well-addr ( well-idx pos -- well-addr )
	INC INC INCk LDZ SWP LDZ SWP
	#00 SWP #0010 MUL2
	ROT #00 SWP ADD2
	;well ADD2
	ROT #00 SWP ADD2
JMP2r

@each-piece-block ( block-func pos -- )
	LDZk #30 SFT ( type ) 
	SWP INC LDZ #10 SFT ( rot )
	ADD #00 SWP 
	;pieces ADD2 LDA2 ( piece16 )
	#33 ( go backward from bottom-right )
	#01 ( col-count, 0-3 )
	SWP2 ( block-func well-idx col-count piece16 )

	&loop

	( test whether a piece block is at well-idx )
	DUP #01 AND ,&ok JCN ,&p-ok JMP
	&ok 
		( put well-idx on top and call block-func ) 
		SWP2 ROT2 OVR2 SWP OVR2 JSR2
		( return stack to previous state )
		POP SWP2 ROT2
	&p-ok

	SWP2 ( block-func piece16 well-idx col-count )
	( col-count %= 4 )
	#04 DIVk MUL SUB
	( if col-count == 0, move to next row )
	SWP OVR ,&inc JCN #0c SUB
	&inc 
	( decrement well-idx )
	#01 SUB SWP
	( increment col-count )
	INC
	SWP2 ( block-func well-idx col-count piece16 )

	( have we run out of piece blocks to try? )
	#01 SFT2 DUP2 #0000 GTH2
		,&loop JCN

	POP2 POP2 POP2
JMP2r

( assets )

@pieces
	&i 0f00 4444 0f00 4444
	&s 4620 6c00 4620 6c00
	&l 4460 0e80 c440 2e00
	&t 0e40 4c40 4e00 4640
	&b 6600 6600 6600 6600
@blank-chr
	ffff ffff ffff ffff
@block-icn
	7e81 8181 8181 817f
	007f 7f7f 7f7f 7f7f

( game data )

|4000

@well $200 &end
